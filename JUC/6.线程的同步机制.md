## 1.背景

例子：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式
*

* 1.问题：卖票过程中，出现了重票、错票 -->出现了线程的安全问题
* 2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。
* 3.如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。

2.Java解决方案：同步机制
在Java中，我们通过synchronized同步机制，来解决线程的安全问题。

#### 【面试】synchronized 和 volatile 的区别是什么？

1. volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。
2. volatile 仅能实现变量的修改可见性和有序性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
3. volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。

#### 方式一：同步代码块

```java
*   synchronized(同步监视器){
*   //需要被同步的代码
*   }
```

⭐synchronized同步代码块:底层实现使用的是**monitorenter**和**monitorexit**指令
 并且一般情况下一个**monitorenter**对应两个**monitorexit**.
 **monitorenter**负责获取锁,**monitorexit**负责释放锁,而第二个**monitorexit**的作用是保证在发生异常时也能够释放锁 。


* **说明：**

   1.操作共享数据的代码，即为需要被同步的代码。  -->不能包含代码多了，也不能包含代码少了。

   2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。

   3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。


   *  要求：多个线程必须要共用同一把锁。。


   *  补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。
          在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。


   **方式二：同步方法**

   如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。

   关于同步方法的总结：

   1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。

   2. 非静态的同步方法，同步监视器是：this

   3. 静态的同步方法，同步监视器是：当前类本身

   **方式三：Lock锁  --- JDK5.0新增**

   **面试题：synchronized 与 Lock的异同？**

* 相同：二者都可以解决线程安全问题

* 不同：1. Lock 是一个接口，而 synchronized 是 Javac中的关键字，synchronized 是内
        置的语言实现；

   	2. synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器
        Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()） 
        3. synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现
        象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很
        可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁； 
        4. Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用
        synchronized 时，等待的线程会一直等待下去，不能够响应中断； 
        5. 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 
        6. Lock 可以提高多个线程进行读操作的效率。 
        在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源
        非常激烈时（即有大量线程同时竞争），此时 Lock 的性能要远远优于synchronized。 

使用的优先顺序：
* Lock ---> 同步代码块（已经进入了方法体，分配了相应资源 ) ---> 同步方法（在方法体之外)

   **方式四：LockSupport锁  --- JDK5.0新增**
1) <u>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语</u>
LockSupport是一个线程阻塞工具类,所有的方法都是静态的可以让线程在任意位置阻塞(spark()),阻塞之后有对应的唤醒方法。

    LockSupport提供park()和unpark(Thread t)方法实现阻塞线程和解除线程阻塞的过程
    LockSupport和每个使用它的线程都有一个许可(permit)关联。
     
    每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累凭证。

 形象的理解
   线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。当调用park方法时
	*如果有凭证，则会直接消耗掉这个凭证然后正常退出;
    *如果无凭证，就必须阻塞等待凭证可用;

 而unpark则相反，它会增加一个凭证，但凭证最多只能有1个，累加无效。

**【面试】一:LockSupport.park()和Object.wait()有什么区别?**
     答:LockSupport是基于Unsafe类,由jdk提供的线程操作工具类,主要作用是挂起线程,唤醒线程 

**【面试】二:为什么LockSupport可以突破wait/notify的原有调用顺序？**
     答：因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。先发放了凭证后续可以畅通无阻。

**【面试】三:为什么唤醒两次后阻塞两次,但最终结果还是会阻塞线程?**
     答: 因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证;而调用两次 park却需要消费两个凭证，证不够，不能放行。

3.利弊
同步的方式，解决了线程的安全问题。---好处
操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。

4.
面试题：Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同
答：三种，同步代码块，同步方法，Lock锁

面试题：synchronized和Lock方式解决线程安全问题的对比